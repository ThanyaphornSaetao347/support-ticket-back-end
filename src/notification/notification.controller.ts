import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Put,
  Param,
  Delete,
  UseGuards,
  Req,
  Query,
  ForbiddenException,
  HttpStatus,
  HttpException,
  ParseIntPipe,

} from '@nestjs/common';
import { NotificationService } from './notification.service';
import { CreateNotificationDto } from './dto/create-notification.dto';
import { Notification, NotificationType } from './entities/notification.entity';
import { UpdateNotificationDto } from './dto/update-notification.dto';
import { JwtAuthGuard } from '../auth/jwt_auth.guard';
import { TicketService } from '../ticket/ticket.service';

@Controller('api')
export class NotificationController {
  constructor(
    private readonly notiService: NotificationService,
    private readonly ticketService: TicketService
  ) { }

  private extractUserId(req: any): number | null {
    console.log('üîç Request user object:', req.user);
    console.log('üîç === extractUserId Debug ===');
    console.log('Full req.user object:', JSON.stringify(req.user, null, 2));

    // ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡∏à‡∏≤‡∏Å‡∏ó‡∏∏‡∏Å property ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡πÑ‡∏î‡πâ
    const possibleUserIds = [
      req.user?.id,
      req.user?.userId,
      req.user?.user_id,
      req.user?.sub,
      req.user?.ID,
      req.user?.Id,
      req.user?.USER_ID
    ];

    console.log('Possible userIds:', possibleUserIds);

    // ‡∏´‡∏≤‡∏Ñ‡πà‡∏≤‡πÅ‡∏£‡∏Å‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà undefined/null
    const userId = possibleUserIds.find(id => id !== undefined && id !== null);

    console.log('Selected userId:', userId, 'Type:', typeof userId);

    // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô number
    const numericUserId = userId ? parseInt(userId.toString()) : null;

    console.log('Final numeric userId:', numericUserId);
    console.log('=== End extractUserId Debug ===');

    return numericUserId;
  }

  private async canAccessTicketByNo(userId: number, ticketNo: string, userPermissions: number[]): Promise<boolean> {
    try {
      if (!userId || !ticketNo) return false;
      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏ö‡∏ö some: ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 permission ‡πÉ‡∏ô [2,12,13] ‚Üí ‡∏ú‡πà‡∏≤‡∏ô
      const allowedRoles = [2, 12, 13];
      const hasPermission = allowedRoles.some(role => userPermissions.includes(role));
      if (hasPermission) return true;

      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡πã‡∏ß
      const owner = await this.isTicketOwnerByNo(userId, ticketNo, userPermissions);
      return owner;
    } catch (error) {
      console.error('Error', error);
      throw error;
    }
  }

  private async isTicketOwnerByNo(userId: number, ticketNo: string, userPermissions: number[]): Promise<boolean> {
    if (!userId || !ticketNo) return false;
    try {
      const isOwner = await this.ticketService.checkTicketOwnershipByNo(userId, ticketNo, userPermissions);
      if (!isOwner) {
        throw new ForbiddenException('‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏ï‡∏±‡πã‡∏ß‡∏ô‡∏µ‡πâ');
      }
      console.log(`üë§ isTicketOwnerByNo: userId=${userId}, ticketNo=${ticketNo}, owner=${isOwner}`);
      return isOwner;
    } catch (error) {
      console.error('üí• isTicketOwnerByNo error:', error);
      return false;
    }
  }

  // Endpoint ‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ ticket ‡πÉ‡∏´‡∏°‡πà‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï/move
  // ‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ticket changes
  @Post('notify-changes')
  async notifyTicketChanges(@Body() payload: {
    ticket_no: string;
    statusId?: number;
    assignedUserId?: number;
    isNewTicket?: boolean;
  }) {
    try {
      const { ticket_no, statusId, assignedUserId, isNewTicket } = payload;

      if (!ticket_no) {
        throw new HttpException(
          { success: false, message: 'ticketNo is required' },
          HttpStatus.BAD_REQUEST
        );
      }

      // ‡πÉ‡∏ä‡πâ notifyAllTicketChanges ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡πÅ‡∏•‡πâ‡∏ß (‡πÉ‡∏ô‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏∞‡∏≠‡∏≤‡∏î)
      const notifications = await this.notiService.notifyAllTicketChanges(ticket_no, {
        statusId,
        assignedUserId,
        isNewTicket
      });

      return {
        success: true,
        message: 'Notifications created and emails sent successfully',
        data: notifications,
        summary: {
          total_notifications: notifications.length,
          new_ticket: isNewTicket ? notifications.filter(n => n.notification_type === NotificationType.NEW_TICKET).length : 0,
          status_change: statusId ? notifications.filter(n => n.notification_type === NotificationType.STATUS_CHANGE).length : 0,
          assignment: assignedUserId ? notifications.filter(n => n.notification_type === NotificationType.ASSIGNMENT).length : 0
        }
      };

    } catch (error) {
      console.error('Error in notifyTicketChanges:', error);
      throw new HttpException(
        {
          success: false,
          message: error.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
        },
        HttpStatus.BAD_REQUEST
      );
    }
  }

  // ‚úÖ Fixed: Get user notifications with proper error handling
  @UseGuards(JwtAuthGuard)
  @Get('getUserNotification')
  async getUserNotification(
    @Req() req: any,
    @Query('page') page: string = '1',
    @Query('limit') limit: string = '20',
    @Query('type') type?: NotificationType
  ) {
    try {
      const userId = this.extractUserId(req);
      if (!userId) {
        throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà');
      }

      // ‚úÖ Proper parameter validation
      const pageNumber = Math.max(1, parseInt(page) || 1);
      const limitNumber = Math.min(100, Math.max(1, parseInt(limit) || 20));

      let result;
      if (type && Object.values(NotificationType).includes(type)) {
        result = await this.notiService.getNotificationsByType(
          userId,
          type,
          pageNumber,
          limitNumber
        );
      } else {
        result = await this.notiService.getUserNotifications(
          userId,
          pageNumber,
          limitNumber
        );
      }

      return {
        success: true,
        data: result,
        message: '‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      };
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new HttpException(
        {
          success: false,
          message: error.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
        },
        HttpStatus.BAD_REQUEST
      );
    }
  }

  // ‚úÖ Get unread count
  @UseGuards(JwtAuthGuard)
  @Get('unread-count')
  async getUnreadCount(@Req() req: any) {
    try {
      const userId = this.extractUserId(req);
      if (!userId) {
        throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà');
      }

      const count = await this.notiService.getUnreadCount(userId);

      return {
        success: true,
        data: {
          unread_count: count,
          user_id: userId,
        },
        message: '‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      };
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new HttpException(
        {
          success: false,
          message: error.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
        },
        HttpStatus.BAD_REQUEST
      );
    }
  }

  // ‚úÖ Get all notification types
  @UseGuards(JwtAuthGuard)
  @Get('getAllType')
  async getNotificationType() {
    try {
      const types = Object.values(NotificationType).map((type) => ({
        value: type,
        label: this.getTypeLabel(type), // ‚úÖ Fixed typo: 'lable' -> 'label'
      }));

      return {
        success: true,
        data: types,
        message: '‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      };
    } catch (error) {
      throw new HttpException(
        {
          success: false,
          message: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
        },
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  // ‚úÖ Get notification by ID with proper authorization
  @UseGuards(JwtAuthGuard)
  @Get('getNotification/:id')
  async getNotificationById(
    @Param('id', ParseIntPipe) id: number,
    @Req() req: any
  ) {
    try {
      const userId = this.extractUserId(req);
      if (!userId) {
        throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà');
      }

      const notification = await this.notiService.findNotificationById(id);

      if (!notification) {
        throw new HttpException(
          {
            success: false,
            message: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£',
          },
          HttpStatus.NOT_FOUND
        );
      }

      // ‚úÖ Check permission to access
      if (notification.user_id !== userId) {
        const isSupporter = await this.notiService.isUserSupporter(userId);
        if (!isSupporter) {
          throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏ô‡∏µ‡πâ');
        }
      }

      return {
        success: true,
        data: notification,
        message: '‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      };
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      if (error instanceof HttpException) {
        throw error;
      }
      throw new HttpException(
        {
          success: false,
          message: error.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
        },
        HttpStatus.BAD_REQUEST
      );
    }
  }

  @Get('notification/:ticket_no')
  @UseGuards(JwtAuthGuard)
  async getTicketNotifications(
    @Param('ticket_no') ticketNo: string,
    @Req() req: any,
    @Query('page') page: string = '1',
    @Query('limit') limit: string = '20'
  ) {
    const userId = this.extractUserId(req);
    if (!userId) throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà');

    const userPermissions: number[] = await this.ticketService.checkUserPermissions(userId);
    console.log('User permission:', userPermissions)

    const canAccess = await this.canAccessTicketByNo(userId, ticketNo, userPermissions);
    if (!canAccess) throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏π‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Ç‡∏≠‡∏á‡∏ï‡∏±‡πã‡∏ß‡∏ô‡∏µ‡πâ');

    const pageNumber = Math.max(1, parseInt(page) || 1);
    const limitNumber = Math.min(100, Math.max(1, parseInt(limit) || 20));

    const result = await this.notiService.getTicketNotifications(ticketNo, pageNumber, limitNumber);

    return {
      success: true,
      data: result,
      message: '‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Ç‡∏≠‡∏á ticket ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
    };
  }

  // ‚úÖ Fixed: Mark single notification as read (was calling markAllAsRead)
  @UseGuards(JwtAuthGuard)
  @Patch('markAsRead/:id')
  async markAsRead(@Param('id', ParseIntPipe) id: number, @Req() req: any) {
    try {
      const userId = this.extractUserId(req);
      if (!userId) {
        throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà');
      }

      // ‚úÖ Fixed: Call markAsRead instead of markAllAsRead
      const result = await this.notiService.markAsRead(id, userId);

      return {
        success: true,
        data: result,
        message: '‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏≠‡πà‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à',
      };
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new HttpException(
        {
          success: false,
          message: error.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏≠‡πà‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß',
        },
        HttpStatus.BAD_REQUEST
      );
    }
  }

  // ‚úÖ Mark all notifications as read
  @UseGuards(JwtAuthGuard)
  @Patch('read-all')
  async markAllRead(@Req() req: any) {
    try {
      const userId = this.extractUserId(req);
      if (!userId) {
        throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà');
      }

      const result = await this.notiService.markAllAsRead(userId);

      return {
        success: true,
        data: {
          update_count: result.updated,
          user_id: userId,
        },
        message: `‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡∏≠‡πà‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß ${result.updated} ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`,
      };
    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new HttpException(
        {
          success: false,
          message: error.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏≠‡πà‡∏≤‡∏ô‡πÅ‡∏•‡πâ‡∏ß',
        },
        HttpStatus.BAD_REQUEST
      );
    }
  }

  private getTypeLabel(type: NotificationType): string {
    const labels: Record<NotificationType, string> = {
      [NotificationType.NEW_TICKET]: '‡∏ï‡∏±‡πã‡∏ß‡πÉ‡∏´‡∏°‡πà',
      [NotificationType.STATUS_CHANGE]: '‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞',
      [NotificationType.ASSIGNMENT]: '‡∏Å‡∏≤‡∏£‡∏°‡∏≠‡∏ö‡∏´‡∏°‡∏≤‡∏¢',
    };

    return labels[type] || '‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó';
  }

  /**
 * ‚úÖ ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ notification ‡∏Ç‡∏≠‡∏á user ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÑ‡∏°‡πà‡∏°‡∏µ pagination)
 * GET /api/notifications/list
 */
  @UseGuards(JwtAuthGuard)
  @Get('notifications/list')
  async getNotificationList(@Req() req: any) {
    try {
      const userId = this.extractUserId(req);
      if (!userId) {
        throw new ForbiddenException('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏π‡πà‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà');
      }

      const result = await this.notiService.getListNoti(userId);
      return result;

    } catch (error) {
      if (error instanceof ForbiddenException) {
        throw error;
      }
      throw new HttpException(
        {
          success: false,
          message: error.message || '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô',
        },
        HttpStatus.BAD_REQUEST
      );
    }
  }
}