import {
  Controller,
  Post,
  Get,
  Param,
  UploadedFiles,
  UseInterceptors,
  Body,
  BadRequestException,
  NotFoundException,
  Request,
  UseGuards,
  Res,
  Delete,
  Patch
} from '@nestjs/common';
import { FilesInterceptor } from '@nestjs/platform-express';
import { diskStorage } from 'multer';
import { extname, join } from 'path';
import * as fs from 'fs';
import * as path from 'path';
import { promisify } from 'util';
import { Response } from 'express';
import { TicketService } from '../ticket/ticket.service';
import { AttachmentService } from './ticket_attachment.service';
import { JwtAuthGuard } from '../auth/jwt_auth.guard';
import { PermissionGuard } from '../permission/permission.guard';
import { RequireAnyAction } from '../permission/permission.decorator';
import { PermissionService } from '../permission/permission.service';

const readFile = promisify(fs.readFile);
const stat = promisify(fs.stat);

// ‡πÄ‡∏Å‡πá‡∏ö counter ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ ticket
const fileCounters = new Map<string, number>();

// ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô getNextFilename ‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏ö‡πÄ‡∏•‡∏Ç‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
export async function getNextFilename(uploadPath: string, ticket_id: string, originalname: string): Promise<string> {
  let existingFiles: string[] = [];
  try {
    existingFiles = await fs.promises.readdir(uploadPath);
  } catch (err) {
    // ‡∏ñ‡πâ‡∏≤‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡πÉ‡∏´‡∏°‡πà
    await fs.promises.mkdir(uploadPath, { recursive: true });
    existingFiles = [];
  }

  // ‚úÖ Filter ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢ ticket_id
  const ticketFiles = existingFiles.filter(f => f.startsWith(`${ticket_id}_`));

  // ‚úÖ Extract ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏à‡∏≤‡∏Å‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡∏∞‡∏´‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
  let maxNumber = 0;

  ticketFiles.forEach(filename => {
    // Pattern: ticket_id_number.extension
    const match = filename.match(new RegExp(`^${ticket_id}_(\\d+)\\.`));
    if (match) {
      const number = parseInt(match[1], 10);
      if (number > maxNumber) {
        maxNumber = number;
      }
    }
  });

  // ‚úÖ ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏ñ‡∏±‡∏î‡πÑ‡∏õ = ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏•‡∏Ç‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î + 1
  const nextNumber = maxNumber + 1;
  const ext = extname(originalname);

  const newFilename = `${ticket_id}_${nextNumber}${ext}`;
  console.log(`üìù Generated filename: ${newFilename} (existing files: ${ticketFiles.length}, max number: ${maxNumber})`);

  return newFilename;
}

export async function getNextFilenameWithCounter(uploadPath: string, ticket_id: string, originalname: string): Promise<string> {
  // ‚úÖ ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ counter ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ticket ‡∏ô‡∏µ‡πâ ‡πÉ‡∏´‡πâ‡∏ô‡∏±‡∏ö‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
  if (!fileCounters.has(ticket_id)) {
    let existingFiles: string[] = [];
    try {
      existingFiles = await fs.promises.readdir(uploadPath);
    } catch (err) {
      await fs.promises.mkdir(uploadPath, { recursive: true });
      existingFiles = [];
    }

    // ‡∏ô‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ticket ‡∏ô‡∏µ‡πâ
    const ticketFiles = existingFiles.filter(f => f.startsWith(`${ticket_id}_`));

    let maxNumber = 0;
    ticketFiles.forEach(filename => {
      const match = filename.match(new RegExp(`^${ticket_id}_(\\d+)\\.`));
      if (match) {
        const number = parseInt(match[1], 10);
        if (number > maxNumber) {
          maxNumber = number;
        }
      }
    });

    fileCounters.set(ticket_id, maxNumber);
  }

  // ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° counter ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
  const currentCounter = fileCounters.get(ticket_id)! + 1;
  fileCounters.set(ticket_id, currentCounter);

  const ext = extname(originalname);
  const newFilename = `${ticket_id}_${currentCounter}${ext}`;

  console.log(`üìù Generated filename with counter: ${newFilename} (counter: ${currentCounter})`);
  return newFilename;
}

@Controller()
export class TicketAttachmentController {
  constructor(
    private readonly ticketService: TicketService,
    private readonly attachmentService: AttachmentService,
    private readonly permissionService: PermissionService,
  ) { }

  // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç endpoint ‡πÄ‡∏î‡∏¥‡∏°‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ô‡∏õ‡∏à‡∏≤‡∏Å issue_attachments
  @Get('images/issue_attachment/:id')
  // @UseGuards(JwtAuthGuard)
  async getIssueAttachmentImage(
    @Param('id') id: number,
    @Res() res: Response
  ) {
    try {
      console.log(`üìé Getting issue attachment file with ID: ${id}`);

      // ‚úÖ ‡∏´‡∏≤ attachment record ‡πÉ‡∏ô database
      const attachment = await this.attachmentService.findById(id);

      if (!attachment) {
        console.log(`‚ùå Attachment ID ${id} not found in database`);
        throw new NotFoundException('Attachment not found');
      }

      console.log(`üìÑ Found attachment: ${JSON.stringify(attachment)}`);

      // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á path ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÑ‡∏ü‡∏•‡πå (‡πÉ‡∏ä‡πâ filename ‡∏à‡∏≤‡∏Å database)
      const filePath = path.join(process.cwd(), 'uploads', 'issue_attachment', attachment.filename);
      console.log(`üìÅ Looking for file at: ${filePath}`);

      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
      try {
        await stat(filePath);
        console.log(`‚úÖ File found: ${filePath}`);
      } catch (error) {
        console.log(`‚ùå File not found: ${filePath}`);
        throw new NotFoundException('File not found on disk');
      }

      // ‚úÖ ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå
      const fileBuffer = await readFile(filePath);
      console.log(`üìñ File read successfully, size: ${fileBuffer.length} bytes`);

      // ‚úÖ ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Content-Type ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå
      const contentTypes = {
        // Images
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'gif': 'image/gif',
        'webp': 'image/webp',
        'bmp': 'image/bmp',
        'tiff': 'image/tiff',
        // Documents
        'pdf': 'application/pdf',
        'doc': 'application/msword',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'xls': 'application/vnd.ms-excel',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'ppt': 'application/vnd.ms-powerpoint',
        'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        // Text files
        'txt': 'text/plain',
        'csv': 'text/csv',
        'json': 'application/json',
        'xml': 'application/xml',
        'rtf': 'application/rtf',
        // Archives
        'zip': 'application/zip',
        'rar': 'application/x-rar-compressed',
        '7z': 'application/x-7z-compressed'
      };

      const extension = attachment.extension.toLowerCase();
      const contentType = contentTypes[extension] || 'application/octet-stream';

      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡πÅ‡∏™‡∏î‡∏á inline ‡∏´‡∏£‡∏∑‡∏≠ download
      const inlineExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'tiff', 'pdf', 'txt', 'json', 'xml'];
      const disposition = inlineExtensions.includes(extension) ? 'inline' : 'attachment';

      // ‚úÖ ‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Å‡∏•‡∏±‡∏ö
      res.set({
        'Content-Type': contentType,
        'Cache-Control': 'public, max-age=3600', // Cache 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
        'Content-Disposition': `${disposition}; filename="${attachment.filename}"`,
        'Content-Length': fileBuffer.length.toString(),
        'X-Attachment-ID': id,
        'X-Ticket-ID': attachment.ticket_id,
        'X-File-Extension': extension
      });

      res.send(fileBuffer);
      console.log(`‚úÖ File sent successfully for ID: ${id}, type: ${contentType}, disposition: ${disposition}`);

    } catch (error) {
      console.error(`üí• Error getting file ${id}:`, error.message);

      if (error instanceof NotFoundException || error instanceof BadRequestException) {
        throw error;
      }

      throw new NotFoundException('File not found');
    }
  }

  // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç endpoint ‡πÄ‡∏î‡∏¥‡∏°‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏∂‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ô‡∏õ‡∏à‡∏≤‡∏Å fix_issue
  @Get('images/fix_issue/:id')
  // @UseGuards(JwtAuthGuard)
  async getFixIssueAttachmentImage(
    @Param('id') id: number,
    @Res() res: Response
  ) {
    try {
      console.log(`üìé Getting fix issue attachment file with ID: ${id}`);

      // ‚úÖ ‡∏´‡∏≤ attachment record ‡πÉ‡∏ô database
      const attachment = await this.attachmentService.findById(id);

      if (!attachment) {
        console.log(`‚ùå Attachment ID ${id} not found in database`);
        throw new NotFoundException('Attachment not found');
      }

      console.log(`üìÑ Found attachment: ${JSON.stringify(attachment)}`);

      // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á path ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÑ‡∏ü‡∏•‡πå (‡πÉ‡∏ä‡πâ filename ‡∏à‡∏≤‡∏Å database)
      const filePath = path.join(process.cwd(), 'uploads', 'fix_issue', attachment.filename);
      console.log(`üìÅ Looking for file at: ${filePath}`);

      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
      try {
        await stat(filePath);
        console.log(`‚úÖ File found: ${filePath}`);
      } catch (error) {
        console.log(`‚ùå File not found: ${filePath}`);
        throw new NotFoundException('File not found on disk');
      }

      // ‚úÖ ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå
      const fileBuffer = await readFile(filePath);
      console.log(`üìñ File read successfully, size: ${fileBuffer.length} bytes`);

      // ‚úÖ ‡∏Å‡∏≥‡∏´‡∏ô‡∏î Content-Type ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå
      const contentTypes = {
        // Images
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'gif': 'image/gif',
        'webp': 'image/webp',
        'bmp': 'image/bmp',
        'tiff': 'image/tiff',
        // Documents
        'pdf': 'application/pdf',
        'doc': 'application/msword',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'xls': 'application/vnd.ms-excel',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'ppt': 'application/vnd.ms-powerpoint',
        'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        // Text files
        'txt': 'text/plain',
        'csv': 'text/csv',
        'json': 'application/json',
        'xml': 'application/xml',
        'rtf': 'application/rtf',
        // Archives
        'zip': 'application/zip',
        'rar': 'application/x-rar-compressed',
        '7z': 'application/x-7z-compressed'
      };

      const extension = attachment.extension.toLowerCase();
      const contentType = contentTypes[extension] || 'application/octet-stream';

      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡πÅ‡∏™‡∏î‡∏á inline ‡∏´‡∏£‡∏∑‡∏≠ download
      const inlineExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'tiff', 'pdf', 'txt', 'json', 'xml'];
      const disposition = inlineExtensions.includes(extension) ? 'inline' : 'attachment';

      // ‚úÖ ‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏Å‡∏•‡∏±‡∏ö
      res.set({
        'Content-Type': contentType,
        'Cache-Control': 'public, max-age=3600', // Cache 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á
        'Content-Disposition': `${disposition}; filename="${attachment.filename}"`,
        'Content-Length': fileBuffer.length.toString(),
        'X-Attachment-ID': id,
        'X-Ticket-ID': attachment.ticket_id,
        'X-File-Extension': extension
      });

      res.send(fileBuffer);
      console.log(`‚úÖ File sent successfully for ID: ${id}, type: ${contentType}, disposition: ${disposition}`);

    } catch (error) {
      console.error(`üí• Error getting file ${id}:`, error.message);

      if (error instanceof NotFoundException || error instanceof BadRequestException) {
        throw error;
      }

      throw new NotFoundException('File not found');
    }
  }

  // üÜï ‡πÄ‡∏û‡∏¥‡πà‡∏° endpoint ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå (force download)
  @Get('download/issue_attachment/:id')
  // @UseGuards(JwtAuthGuard)
  async downloadIssueAttachment(
    @Param('id') id: number,
    @Res() res: Response
  ) {
    try {
      console.log(`‚¨áÔ∏è Downloading issue attachment with ID: ${id}`);

      // ‚úÖ ‡∏´‡∏≤ attachment record ‡πÉ‡∏ô database
      const attachment = await this.attachmentService.findById(id);

      if (!attachment) {
        console.log(`‚ùå Attachment ID ${id} not found in database`);
        throw new NotFoundException('Attachment not found');
      }

      console.log(`üìÑ Found attachment for download: ${JSON.stringify(attachment)}`);

      // ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á path ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡πÑ‡∏ü‡∏•‡πå
      const filePath = path.join(process.cwd(), 'uploads', 'issue_attachment', attachment.filename);
      console.log(`üìÅ Looking for file at: ${filePath}`);

      // ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡∏à‡∏£‡∏¥‡∏á
      try {
        const stats = await stat(filePath);
        console.log(`‚úÖ File found: ${filePath}, size: ${stats.size} bytes`);

        // ‚úÖ ‡πÉ‡∏ä‡πâ res.download() ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î
        res.download(filePath, attachment.filename, (err) => {
          if (err) {
            console.error(`‚ùå Download error for file ${id}:`, err);
            if (!res.headersSent) {
              throw new NotFoundException('File download failed');
            }
          } else {
            console.log(`‚úÖ File downloaded successfully: ${attachment.filename}`);
          }
        });

      } catch (error) {
        console.log(`‚ùå File not found: ${filePath}`);
        throw new NotFoundException('File not found on disk');
      }

    } catch (error) {
      console.error(`üí• Error downloading file ${id}:`, error.message);

      if (error instanceof NotFoundException || error instanceof BadRequestException) {
        throw error;
      }

      throw new NotFoundException('File not found');
    }
  }

  // ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏ô‡∏õ‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡∏¥‡∏Å‡πÄ‡∏Å‡πá‡∏ï
  @Post('api/updateAttachment')
  @UseGuards(JwtAuthGuard, PermissionGuard)
  @RequireAnyAction('create_ticket')
  @UseInterceptors(FilesInterceptor('files', 5, {
    storage: diskStorage({
      destination: './uploads/issue_attachment',
      filename: async (req, file, cb) => {
        const ticket_id = req.body?.ticket_id || req.query?.ticket_id;
        if (!ticket_id) return cb(new BadRequestException('ticket_id is required'), '');

        try {
          // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß
          const newFilename = await getNextFilenameWithCounter('./uploads/issue_attachment', ticket_id, file.originalname);
          cb(null, newFilename);
        } catch (error) {
          cb(error, '');
        }
      }
    }),
    fileFilter: (req, file, cb) => {
      console.log('File being uploaded:', {
        fieldname: file.fieldname,
        originalname: file.originalname,
        mimetype: file.mimetype,
        size: file.size
      });

      // ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ MIME types ‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï
      const allowedMimeTypes = [
        // Images
        'image/jpeg',
        'image/jpg',
        'image/png',
        'image/gif',
        'image/webp',
        'image/bmp',
        'image/tiff',
        // Documents
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-powerpoint',
        'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        // Text files
        'text/plain',
        'text/csv',
        'application/json',
        // Archives
        'application/zip',
        'application/x-rar-compressed',
        'application/x-7z-compressed',
        'application/x-zip-compressed',
        // Other common formats
        'application/rtf',
        'application/xml',
        'text/xml'
      ];

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö extension ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡πà‡πÉ‡∏à)
      const allowedExtensions = [
        '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff',
        '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
        '.txt', '.csv', '.json', '.xml', '.rtf',
        '.zip', '.rar', '.7z'
      ];

      const fileExtension = extname(file.originalname).toLowerCase();

      if (allowedMimeTypes.includes(file.mimetype) || allowedExtensions.includes(fileExtension)) {
        cb(null, true);
      } else {
        console.log('File type not allowed:', {
          mimetype: file.mimetype,
          extension: fileExtension,
          filename: file.originalname
        });

        return cb(
          new BadRequestException(
            `File type '${file.mimetype}' with extension '${fileExtension}' is not allowed. ` +
            `Allowed types: images, PDF, Word, Excel, PowerPoint, text files, and archives.`
          ),
          false
        );
      }
    },
    limits: {
      fileSize: 10 * 1024 * 1024, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 10MB
    }
  }))
  async updateAttachment(
    @UploadedFiles() files: Express.Multer.File[],
    @Body('ticket_id') ticket_id: string,
    @Body('project_id') project_id: string,
    @Body('categories_id') categories_id: string,
    @Body('issue_description') issue_description: string,
    @Body('type') type: string = 'reporter',
    @Request() req: any
  ) {
    try {
      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
      if (!files || files.length === 0) {
        throw new BadRequestException('No files uploaded');
      }

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö ticket_id
      if (!ticket_id) {
        throw new BadRequestException('ticket_id is required');
      }

      const uploadedFiles: any[] = [];
      const errors: any[] = [];

      // Process ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå
      for (const file of files) {
        try {
          // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå
          const processedFile = await this.processImage(file);

          // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ AttachmentService ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
          const attachment = await this.attachmentService.create({
            ticket_id: parseInt(ticket_id), // ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô number
            type,
            file: file, // ‡∏™‡πà‡∏á Express.Multer.File object ‡∏ï‡∏£‡∏á‡πÜ
            create_by: req.user.id
          });

          // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (project_id, category_id, issue_description) ‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡∏ï‡πà‡∏≠
          if (project_id || categories_id || issue_description) {
            console.log('Additional data to process:', {
              project_id,
              categories_id,
              issue_description,
              attachment_id: attachment.id
            });
            // ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° logic ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏≠‡∏∑‡πà‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà
          }

          uploadedFiles.push({
            id: attachment.id,
            filename: attachment.filename, // ‡πÉ‡∏ä‡πâ filename ‡∏à‡∏≤‡∏Å database
            original_name: file.originalname,
            file_size: processedFile.size,
            file_url: `/images/issue_attachment/${attachment.id}`, // ‚úÖ ‡πÉ‡∏ä‡πâ endpoint ‡πÄ‡∏î‡∏¥‡∏°
            extension: attachment.extension
          });

          // ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå temp ‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
          if (file.filename !== processedFile.filename) {
            await this.deleteFile(file.path);
          }

        } catch (error) {
          console.error('File processing error:', error);

          // ‡∏•‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà upload ‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
          if (file.path) {
            await this.deleteFile(file.path);
          }

          errors.push({
            filename: file.originalname,
            error: error.message
          });
        }
      }

      // ‡∏™‡πà‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
      const response = {
        success: uploadedFiles.length > 0,
        message: `Successfully uploaded ${uploadedFiles.length} file(s)`,
        data: {
          uploaded_files: uploadedFiles,
          total_uploaded: uploadedFiles.length,
          total_files: files.length,
          errors: errors.length > 0 ? errors : undefined
        }
      };

      if (errors.length === 0) {
        return response;
      }

      if (uploadedFiles.length > 0) {
        return {
          ...response,
          message: `Uploaded ${uploadedFiles.length}/${files.length} files with some errors`
        };
      }

      throw new BadRequestException({
        message: 'Failed to upload any files',
        errors: errors
      });

    } catch (error) {
      console.error('Upload error:', error);

      // ‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
      if (files && files.length > 0) {
        for (const file of files) {
          if (file.path) {
            await this.deleteFile(file.path);
          }
        }
      }
      throw error;
    }
  }

  // ‡πÉ‡∏ä‡πÄ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï‡πÑ‡∏ü‡∏•‡πå‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ó‡∏¥‡∏Å‡πÄ‡∏Å‡πá‡∏ï‡∏Ç‡∏≠‡∏á‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤
  @Patch('api/update_attachment')
  @UseGuards(JwtAuthGuard, PermissionGuard)
  @RequireAnyAction('create_ticket')
  @UseInterceptors(FilesInterceptor('files', 5, {
    storage: diskStorage({
      destination: './uploads/issue_attachment', // ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô issue_attachment ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà fix_issue
      filename: async (req, file, cb) => {
        const ticket_id = req.body?.ticket_id || req.query?.ticket_id;
        if (!ticket_id) return cb(new BadRequestException('ticket_id is required'), '');

        try {
          // ‚úÖ ‡πÉ‡∏ä‡πâ path ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
          const newFilename = await getNextFilenameWithCounter('./uploads/issue_attachment', ticket_id, file.originalname);
          cb(null, newFilename);
        } catch (error) {
          cb(error, '');
        }
      }
    }),
    fileFilter: (req, file, cb) => {
      console.log('File being uploaded:', {
        fieldname: file.fieldname,
        originalname: file.originalname,
        mimetype: file.mimetype,
        size: file.size
      });

      // ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ MIME types ‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï
      const allowedMimeTypes = [
        // Images
        'image/jpeg',
        'image/jpg',
        'image/png',
        'image/gif',
        'image/webp',
        'image/bmp',
        'image/tiff',
        // Documents
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-powerpoint',
        'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        // Text files
        'text/plain',
        'text/csv',
        'application/json',
        // Archives
        'application/zip',
        'application/x-rar-compressed',
        'application/x-7z-compressed',
        'application/x-zip-compressed',
        // Other common formats
        'application/rtf',
        'application/xml',
        'text/xml'
      ];

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö extension ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡πà‡πÉ‡∏à)
      const allowedExtensions = [
        '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff',
        '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
        '.txt', '.csv', '.json', '.xml', '.rtf',
        '.zip', '.rar', '.7z'
      ];

      const fileExtension = extname(file.originalname).toLowerCase();

      if (allowedMimeTypes.includes(file.mimetype) || allowedExtensions.includes(fileExtension)) {
        cb(null, true);
      } else {
        console.log('File type not allowed:', {
          mimetype: file.mimetype,
          extension: fileExtension,
          filename: file.originalname
        });

        return cb(
          new BadRequestException(
            `File type '${file.mimetype}' with extension '${fileExtension}' is not allowed. ` +
            `Allowed types: images, PDF, Word, Excel, PowerPoint, text files, and archives.`
          ),
          false
        );
      }
    },
    limits: {
      fileSize: 10 * 1024 * 1024, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 10MB
    }
  }))
  async fix_updateAttachment(
    @UploadedFiles() files: Express.Multer.File[],
    @Body('ticket_id') ticket_id: string,
    @Request() req: any,   // ‚úÖ ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡∏î‡∏∂‡∏á user id
  ) {
    try {
      if (!files || files.length === 0) {
        throw new BadRequestException('No files uploaded');
      }

      if (!ticket_id) {
        throw new BadRequestException('ticket_id is required');
      }

      const uploadedFiles: any[] = [];
      const errors: any[] = [];

      for (const file of files) {
        try {
          const processedFile = await this.processImage(file);

          // ‚úÖ ‡∏™‡πà‡∏á parameter ‡∏Ñ‡∏£‡∏ö‡∏ï‡∏≤‡∏° type definition
          const attachment = await this.attachmentService.create({
            ticket_id: parseInt(ticket_id),
            type: 'reporter',       // fix ‡∏Ñ‡πà‡∏≤ default
            file,                   // multer file
            create_by: req.user.id, // ‡∏à‡∏≤‡∏Å JWT user
          });

          uploadedFiles.push({
            id: attachment.id,
            filename: attachment.filename,
            original_name: file.originalname,
            file_size: processedFile.size,
            file_url: `/images/issue_attachment/${attachment.id}`,
            extension: attachment.extension,
          });

          if (file.filename !== processedFile.filename) {
            await this.deleteFile(file.path);
          }

        } catch (error) {
          console.error('File processing error:', error);

          if (file.path) {
            await this.deleteFile(file.path);
          }

          errors.push({
            filename: file.originalname,
            error: error.message,
          });
        }
      }

      const response = {
        success: uploadedFiles.length > 0,
        message: `Successfully uploaded ${uploadedFiles.length} file(s)`,
        data: {
          uploaded_files: uploadedFiles,
          total_uploaded: uploadedFiles.length,
          total_files: files.length,
          errors: errors.length > 0 ? errors : undefined,
        },
      };

      if (errors.length === 0) return response;

      if (uploadedFiles.length > 0) {
        return {
          ...response,
          message: `Uploaded ${uploadedFiles.length}/${files.length} files with some errors`,
        };
      }

      throw new BadRequestException({
        message: 'Failed to upload any files',
        errors: errors,
      });

    } catch (error) {
      console.error('Upload error:', error);

      if (files && files.length > 0) {
        for (const file of files) {
          if (file.path) {
            await this.deleteFile(file.path);
          }
        }
      }
      throw error;
    }
  }

  // ‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÅ‡∏ô‡∏õ‡πÑ‡∏ü‡∏•‡∏•‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á support information ‡∏Ç‡∏≠‡∏á supporter
  @Patch('api/fix_issue/attachment')
  @UseGuards(JwtAuthGuard, PermissionGuard)
  @RequireAnyAction('solve_problem')
  @UseInterceptors(FilesInterceptor('files', 5, {
    storage: diskStorage({
      destination: './uploads/fix_issue',
      filename: async (req, file, cb) => {
        const ticket_id = req.body?.ticket_id || req.query?.ticket_id;
        if (!ticket_id) {
          console.error('ticket_id is missing in form-data');
          return cb(new BadRequestException('ticket_id is required'), '');
        }

        try {
          // ‚úÖ ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß
          const newFilename = await getNextFilenameWithCounter('./uploads/fix_issue', ticket_id, file.originalname);
          cb(null, newFilename);
        } catch (error) {
          cb(error, '');
        }
      }
    }),
    fileFilter: (req, file, cb) => {
      console.log('File being uploaded:', {
        fieldname: file.fieldname,
        originalname: file.originalname,
        mimetype: file.mimetype,
        size: file.size
      });

      // ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ MIME types ‡∏ó‡∏µ‡πà‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï
      const allowedMimeTypes = [
        // Images
        'image/jpeg',
        'image/jpg',
        'image/png',
        'image/gif',
        'image/webp',
        'image/bmp',
        'image/tiff',
        // Documents
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'application/vnd.ms-excel',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'application/vnd.ms-powerpoint',
        'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        // Text files
        'text/plain',
        'text/csv',
        'application/json',
        // Archives
        'application/zip',
        'application/x-rar-compressed',
        'application/x-7z-compressed',
        'application/x-zip-compressed',
        // Other common formats
        'application/rtf',
        'application/xml',
        'text/xml'
      ];

      // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö extension ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡πà‡πÉ‡∏à)
      const allowedExtensions = [
        '.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.tiff',
        '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',
        '.txt', '.csv', '.json', '.xml', '.rtf',
        '.zip', '.rar', '.7z'
      ];

      const fileExtension = extname(file.originalname).toLowerCase();

      if (allowedMimeTypes.includes(file.mimetype) || allowedExtensions.includes(fileExtension)) {
        cb(null, true);
      } else {
        console.log('File type not allowed:', {
          mimetype: file.mimetype,
          extension: fileExtension,
          filename: file.originalname
        });

        return cb(
          new BadRequestException(
            `File type '${file.mimetype}' with extension '${fileExtension}' is not allowed. ` +
            `Allowed types: images, PDF, Word, Excel, PowerPoint, text files, and archives.`
          ),
          false
        );
      }
    },
    limits: {
      fileSize: 10 * 1024 * 1024, // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πá‡∏ô 10MB
    }
  }))
  async fix_issue_attachment(
    @UploadedFiles() files: Express.Multer.File[],
    @Body('ticket_id') ticket_id: string,
    @Request() req: any,   // ‚úÖ ‡πÄ‡∏≠‡∏≤‡πÑ‡∏ß‡πâ‡∏î‡∏∂‡∏á user id
  ) {
    try {
      if (!files || files.length === 0) {
        throw new BadRequestException('No files uploaded');
      }

      if (!ticket_id) {
        throw new BadRequestException('ticket_id is required');
      }

      const uploadedFiles: any[] = [];
      const errors: any[] = [];

      for (const file of files) {
        try {
          const processedFile = await this.processImage(file);

          // ‚úÖ ‡∏™‡πà‡∏á parameter ‡∏Ñ‡∏£‡∏ö‡∏ï‡∏≤‡∏° type definition
          const attachment = await this.attachmentService.create({
            ticket_id: parseInt(ticket_id),
            type: 'reporter',       // fix ‡∏Ñ‡πà‡∏≤ default
            file,                   // multer file
            create_by: req.user.id, // ‡∏à‡∏≤‡∏Å JWT user
          });

          uploadedFiles.push({
            id: attachment.id,
            filename: attachment.filename,
            original_name: file.originalname,
            file_size: processedFile.size,
            file_url: `/images/fix_issue/${attachment.id}`,
            extension: attachment.extension,
          });

          if (file.filename !== processedFile.filename) {
            await this.deleteFile(file.path);
          }

        } catch (error) {
          console.error('File processing error:', error);

          if (file.path) {
            await this.deleteFile(file.path);
          }

          errors.push({
            filename: file.originalname,
            error: error.message,
          });
        }
      }

      const response = {
        success: uploadedFiles.length > 0,
        message: `Successfully uploaded ${uploadedFiles.length} file(s)`,
        data: {
          uploaded_files: uploadedFiles,
          total_uploaded: uploadedFiles.length,
          total_files: files.length,
          errors: errors.length > 0 ? errors : undefined,
        },
      };

      if (errors.length === 0) return response;

      if (uploadedFiles.length > 0) {
        return {
          ...response,
          message: `Uploaded ${uploadedFiles.length}/${files.length} files with some errors`,
        };
      }

      throw new BadRequestException({
        message: 'Failed to upload any files',
        errors: errors,
      });

    } catch (error) {
      console.error('Upload error:', error);

      if (files && files.length > 0) {
        for (const file of files) {
          if (file.path) {
            await this.deleteFile(file.path);
          }
        }
      }
      throw error;
    }
  }

  // Helper methods
  private async deleteFile(filePath: string): Promise<void> {
    try {
      const fs = require('fs').promises;
      await fs.unlink(filePath);
    } catch (error) {
      console.error('Failed to delete file:', filePath, error);
    }
  }

  private async processImage(file: Express.Multer.File): Promise<{
    filename: string;
    path: string;
    size: number;
  }> {
    return {
      filename: file.filename,
      path: file.path,
      size: file.size
    };
  }

  @Delete('api/images/issue_attachment/:id')
  @UseGuards(JwtAuthGuard)
  async deleteAttachment(
    @Param('id') id: number,
    @Request() req: any
  ) {
    const userId = req.user?.id;
    return this.attachmentService.deleteAttachment(Number(id), userId);
  }
}
